---
title: "Title"
author: "Christian Oppegård Moen"
date: "DD MM YYYY"
output: 
  bookdown::pdf_document2:
    toc_depth: '3' # Depth of contents
    number_sections: false
  # pdf_document:
  # #   toc: no
  #   toc_depth: '3'
subtitle: Course
urlcolor: blue
editor_options: 
  chunk_output_type: console
header-includes:
- \usepackage[width=0.8\textwidth]{caption} # add caption to figures.
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = T, tidy=T, message=F, warning=F,
  strip.white=F, # Strips whitespace
  prompt=F, #?
  cache=T, # Cache for quick knit.
  # root.dir = "./subfolder",
  size="scriptsize",
  fig.width=7, 
  fig.height=5, 
  fig.align = "center"
)
```

```{r config, include=F}
if (F){
  setwd("C:/Users/kikka/OneDrive - NTNU/Fysmat/8 Semester V2022/RomStat/romstat/project3")
  options(error=recover)
  options(error=NULL)
}
```

# Libraries
```{r librarys, options}
library(glmm)
library(dplyr)
```

# Data
Data format is of tab separated values regarding noise on campus. Some variables are shown in the printout below. The response is `spmTriv` and `spmEff` which are "trivsel" and "effektivitet", respectively. The response is evaluated for each building block.

## Load data and reformat
```{r reformatTime, options}
pathData = "./data"
d = read.delim("./data/data-315297-2023-03-08-1434-utf.txt", header=T)

# Reformat the time to be total time in seconds
formatTime <- function(t) {
  tSplit = strsplit(t, ' ')[[1]]
  s=0
  for (i in seq(1, length(tSplit), 2)){
    s = s + switch(
      tSplit[i+1],
      "dag" = strtoi(tSplit[i])*24*3600,
      "dager" = strtoi(tSplit[i])*24*3600,
      "time" = strtoi(tSplit[i])*3600,
      "timer" = strtoi(tSplit[i])*3600,
      "minutt" = strtoi(tSplit[i])*60,
      "minutter" = strtoi(tSplit[i])*60,
      "sekund" = strtoi(tSplit[i]),
      "sekunder" = strtoi(tSplit[i]),
      0
    )
  }
  return(s)
}

ftimes = unlist(lapply(d$Svartid, formatTime))
head(cbind(old=d$Svartid, new=ftimes))
d$Svartid=ftimes
```

```{r freeTextToFile, eval=F}
write.csv(d[d[,'spmTekst']!="",c('NR','spmTekst')],"./data/freeTxt.csv", row.names = FALSE)
```


```{r anc, options}
N = length(d[,1])
ancPercentage = length(d$spmTiltak_1[d$spmTiltak_1=='mNc']) / N
ancPercentage
```

## Response (empirical mean and standard deviations (SD))
Compute per building means and SDs
```{r response, options}
# All locations/buildings
locs = unique(d$spmHvor)

# initiate per building empirical mean data frame
buildMeans = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
# initiate per building standard deviation data frame
buildSd = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
# Compute means and SDs
for (loc in locs){
  buildMeans[loc] = c(mean(d$spmTriv[d$spmHvor==loc]),
             mean(d$spmEff[d$spmHvor==loc]))
  buildSd[loc] = c(sd(d$spmTriv[d$spmHvor==loc]),
             sd(d$spmEff[d$spmHvor==loc]))
} 
buildMeans[1:5]
buildSd[1:5]
rbind(buildMeans,buildSd)[1:5]
```

```{r writeTo.dat, options}
# means
write.table(
  t(buildMeans['trivsel',]), 
  file= paste(pathData,'/trivselPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildMeans['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
# Standard deviations (sd)
write.table(
  t(buildSd['trivsel',]), 
  file= paste(pathData,'/trivselPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildSd['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
```

```{r barplotSave, include=FALSE, eval=FALSE}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5
pdf(file = './figures/histTrivsel&Effektivitet.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
dev.off()
```

```{r barplotResponses, options}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5
barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')

mTriv= max(buildMeans['trivsel',])
mEff = max(buildMeans['effektivitet',])
buildMeans['effektivitet',buildMeans['effektivitet',]==mEff]
buildMeans['trivsel',buildMeans['trivsel',]==mTriv]

# sort(buildMeans['trivsel',], decreasing = T)
```

```{r barplotResponseSD, options}
barplot(
  ((as.matrix(buildSd))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  las=2,
  # ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
```

```{r saveBarplotResponsesSD, options}
pdf(file = './figures/histTrivsel&EffektivitetSD.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(buildSd))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  las=2,
  # ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
dev.off()
```


# Make building data
```{r buildingSpecificVariables, options}
buildings = split(d, f=d$spmHvor)
for (build in buildings){
  print(mean(build$spmTriv))
}
```

# GLMM fit on errytin'
```{r GLMMall, eval=F}
set.seed(420)
fitAll = glmm(spmTriv~0+Svartid, varcomps.names = c(""), data = d, family.glmm = Gaussian)
dSummary = summary(d)
head(d)
```

# GLM fit on Svartid
```{r GLMtid, options}
# Fit
fitTidTriv = glm(factor(spmTriv, seq(1,5,1))~Svartid , data = d, family = "binomial")
fitTidEff = glm(factor(spmEff, seq(1,5,1))~Svartid , data = d, family = "binomial")

summary(fitTidTriv)$coefficients
summary(fitTidEff)$coefficients
summary(fitTidEff)
```

# GLM fit on noise types
```{r glmNoiseTypes, options}
factors = c('spmTriv', 'spmEff',
            'byggestoy1', 'personstoy1','trafikk1','vifte1', 'annet1',
            'byggestoy2', 'personstoy2','trafikk2','vifte2', 'annet2'
            )
dFactored = d
# factorize = function()
for (f in factors){
  dFactored[f,] = factor(d[f,], seq(1,5,1), ordered = T)
}

fitTrivSource = glm(
  factor(spmTriv, seq(1,5,1), ordered = T)~byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
  data = dFactored, family = "binomial"
)
summary(fitTrivSource)
cov(d$spmTriv, d$byggestoy1)
cov(d$spmEff, d$byggestoy2)
par(d)
```

# Initial data observations
```{r initial, options}
hist(d$spmTriv, breaks = seq(0.5,5.5,1), freq = T)
lines(density(d$spmTriv, bw=1, from = 1, to = 5))
hist(d$spmEff, breaks = seq(0.5,5.5,1), freq = T)
lines(density(d$spmEff, bw=1, from = 1, to = 5))
```


# Linear models
```{r linMods, options}
lmTrivSource = lm(
  spmTriv ~ -1 + byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
  data=d
)
summary(lmTrivSource)
# pairs(d[,apply(d[1,],2, FUN=is.numeric)])
```

```{r numericVals, options}
dNumeric = select_if(d,is.numeric)
head(dNumeric[,2:7])
lmTrivSource = lm(spmTriv~., data = dNumeric[2:7])
lmTrivCoefs = summary(lmTrivSource)$coefficients
lmTIntercept = lmTrivCoefs['(Intercept)', 'Estimate']
lmTBygg = lmTrivCoefs['byggestoy1', 'Estimate']
lmTPers = lmTrivCoefs['personstoy1', 'Estimate']
lmTVift = lmTrivCoefs['vifte1', 'Estimate']
yEst = lmTBygg*(1:5) + lmTPers*(1:5) + lmTVift*(1:5)
plot(dNumeric[,'byggestoy1'], dNumeric[,'spmTriv'], )
plot(yEst)
```

```{r pairs, options}
pairs(dNumeric[,2:7])
library(GGally)
ggpairs(dNumeric[,2:7])
ggpairs(dNumeric[,8:13])
```

# Building relations
```{r buildingLm, options}

```



# ANC and noise type correlation
How to do this?
Initially we will look at noise types and how much they disturb when the individual uses ANC compared to when the individual is not.
```{r ANCNoisetype, options}
ntTriv = colnames(d)[7:11]
ntEff = colnames(d)[13:17]
ntColnames = c(
  'Konstruksjon', 'Person', 'Trafikk', 'Vifte', 'Annet')
ntRownames = c(
  'Trivsel m/ ANC', 'Trivsel u/ ANC', 'Effektivitet m/ ANC',
  'Effektivitet u/ ANC')
ntAnc = data.frame(
  matrix(
    ncol = length(ntTriv), nrow = 4,
    dimnames=list(ntRownames, ntColnames)
  )
)

# Find mean noise type disturbances
ancBool = d[,"spmTiltak_1"] == "mNc"
ntAnc[ntColnames] = c(
  apply(d[ancBool, ntTriv], FUN = mean, MARGIN = 2),
  apply(d[!ancBool, ntTriv], FUN = mean, MARGIN = 2),
  apply(d[ancBool,ntEff], FUN = mean, MARGIN = 2),
  apply(d[!ancBool,ntEff], FUN = mean, MARGIN = 2)
)

# Barplot
reOrder = c(1,3,2,4)
cols = c("#b1fbf5", '#d5a7fb', '#59f7ea', '#be77f9')
barplot(
  ((as.matrix(ntAnc[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  # las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')
```

```{r saveANCnoiseType, eval=F, include=F}
pdf(file = './figures/histANCnoiseType.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(ntAnc[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  # las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')
dev.off()
```

