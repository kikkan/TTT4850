---
title: "Title"
author: "Christian Oppegård Moen"
date: "DD MM YYYY"
output: 
  bookdown::pdf_document2:
    toc_depth: '3' # Depth of contents
    number_sections: false
  # pdf_document:
  # #   toc: no
  #   toc_depth: '3'
subtitle: Course
urlcolor: blue
editor_options: 
  chunk_output_type: console
header-includes:
- \usepackage[width=0.8\textwidth]{caption} # add caption to figures.
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = T, tidy=T, message=F, warning=F,
  strip.white=F, # Strips whitespace
  prompt=F, #?
  cache=T, # Cache for quick knit.
  # root.dir = "./subfolder",
  size="scriptsize",
  fig.width=7, 
  fig.height=5, 
  fig.align = "center"
)
```

```{r config, include=F}
if (F){
  setwd("C:/Users/kikka/OneDrive - NTNU/Fysmat/8 Semester V2022/RomStat/romstat/project3")
  options(error=recover)
  options(error=NULL)
}
```

# Libraries
```{r libraries, options}
library(Rmisc)
library(glmm)
library(ggplot2)
library(tidyr)
library(dplyr)
# library(MASS) 
# library(reshape2) 
# library(reshape) 
```

```{r defaultSettings, options}
defaultMar = c(5.1, 4.1, 4.1, 2.1)

```

# Data
Data format is of tab separated values regarding noise on campus. Some variables are shown in the printout below. The response is `spmTriv` and `spmEff` which are "trivsel" and "effektivitet", respectively. The response is evaluated for each building block.

## Load data and reformat
The time is on a unfeasible format, so we format it to total seconds used.
```{r reformatTime, options}
pathData = "./data"
d = read.delim("./data/data-315297-2023-03-08-1434-utf.txt", header=T)

# Reformat the time to be total time in seconds
formatTime <- function(t) {
  tSplit = strsplit(t, ' ')[[1]]
  s=0
  for (i in seq(1, length(tSplit), 2)){
    s = s + switch(
      tSplit[i+1],
      "dag" = strtoi(tSplit[i])*24*3600,
      "dager" = strtoi(tSplit[i])*24*3600,
      "time" = strtoi(tSplit[i])*3600,
      "timer" = strtoi(tSplit[i])*3600,
      "minutt" = strtoi(tSplit[i])*60,
      "minutter" = strtoi(tSplit[i])*60,
      "sekund" = strtoi(tSplit[i]),
      "sekunder" = strtoi(tSplit[i]),
      0
    )
  }
  return(s)
}

ftimes = unlist(lapply(d$Svartid, formatTime))
head(cbind(old=d$Svartid, new=ftimes))
d$Svartid=ftimes
```

```{r freeTextToFile, eval=F, include=F}
write.csv(d[d[,'spmTekst']!="",c('NR','spmTekst')],"./data/freeTxt.csv", row.names = FALSE)
```

# Anc data someone wanted
```{r anc, options}
N = length(d[,1])
ancPercentage = length(d$spmTiltak_1[d$spmTiltak_1=='mNc']) / N
ancPercentage
```

# Response (empirical mean and standard deviations (SD))
## Compute per building means and SDs
```{r response, options}
# All locations/buildings
locs = unique(d$spmHvor)

# initiate per building empirical mean data frame
buildMeans = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
# initiate per building standard deviation data frame
buildSd = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
# Compute means and SDs
for (loc in locs){
  buildMeans[loc] = c(mean(d$spmTriv[d$spmHvor==loc]),
             mean(d$spmEff[d$spmHvor==loc]))
  buildSd[loc] = c(sd(d$spmTriv[d$spmHvor==loc]),
             sd(d$spmEff[d$spmHvor==loc]))
} 
buildMeans[1:5]
buildSd[1:5]
# rbind(buildMeans,buildSd)[1:5]
```

```{r writeTo.dat, eval=F, include=F}
# means
write.table(
  t(buildMeans['trivsel',]), 
  file= paste(pathData,'/trivselPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildMeans['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
# Standard deviations (sd)
write.table(
  t(buildSd['trivsel',]), 
  file= paste(pathData,'/trivselPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildSd['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
```

```{r responseBarplotSave, include=FALSE, eval=FALSE}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5
pdf(file = './figures/histTrivsel&Effektivitet.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
dev.off()
```


## Barplot of responses
```{r barplotResponses, options}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5

barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
d['Elektro_D.B2',]
head(d)
mTriv= max(buildMeans['trivsel',])
mEff = max(buildMeans['effektivitet',])
buildMeans['effektivitet',buildMeans['effektivitet',]==mEff]
buildMeans['trivsel',buildMeans['trivsel',]==mTriv]

# sort(buildMeans['trivsel',], decreasing = T)
```

```{r barplotResponseSD, options}
barplot(
  ((as.matrix(buildSd))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  las=2,
  # ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
```

```{r saveBarplotResponsesSD, eval=FALSE, include=FALSE}
pdf(file = './figures/histTrivsel&EffektivitetSD.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(buildSd))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  las=2,
  # ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
dev.off()
```


# Make building data
```{r buildingSpecificVariables, options}
# buildings = split(d, f=d$spmHvor)
# for (build in buildings){
#   print(mean(build$spmTriv))
# }
```

# GLMM fit on errytin'
```{r GLMMall, eval=F}
# set.seed(420)
# fitAll = glmm(spmTriv~0+Svartid, varcomps.names = c(""), data = d, family.glmm = Gaussian)
# dSummary = summary(d)
# head(d)
```

# GLM fit on Svartid
```{r GLMtid, options}
# # Fit
# fitTidTriv = glm(factor(spmTriv, seq(1,5,1))~Svartid , data = d, family = "binomial")
# fitTidEff = glm(factor(spmEff, seq(1,5,1))~Svartid , data = d, family = "binomial")
# 
# summary(fitTidTriv)$coefficients
# summary(fitTidEff)$coefficients
# summary(fitTidEff)
```

# GLM fit on noise types
```{r glmNoiseTypes, options}
# factors = c('spmTriv', 'spmEff',
#             'byggestoy1', 'personstoy1','trafikk1','vifte1', 'annet1',
#             'byggestoy2', 'personstoy2','trafikk2','vifte2', 'annet2'
#             )
# dFactored = d
# # factorize = function()
# for (f in factors){
#   dFactored[f,] = factor(d[f,], seq(1,5,1), ordered = T)
# }
# 
# fitTrivSource = glm(
#   factor(spmTriv, seq(1,5,1), ordered = T)~byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
#   data = dFactored, family = "binomial"
# )
# summary(fitTrivSource)
# cov(d$spmTriv, d$byggestoy1)
# cov(d$spmEff, d$byggestoy2)
# par(d)
```

# Initial data observations
Histograms of `effektivitet` and `trivsel` showing how many answered 1,2,3,...
```{r initial, options}
hist(d$spmTriv, breaks = seq(0.5,5.5,1), freq = T)
lines(density(d$spmTriv, bw=1, from = 1, to = 5))
hist(d$spmEff, breaks = seq(0.5,5.5,1), freq = T)
lines(density(d$spmEff, bw=1, from = 1, to = 5))
```

# Empiric data
```{r empiricShit, options}
# head(d)
# head(d[,18:(18+6)])
dTiltak = d[,18:(18+6)]
hasAns = function(x){return (sum(x!=""))}
dTiltakSum = apply(dTiltak, FUN = hasAns, MARGIN = 2)
dTiltakSum
```


# Linear models
Fitting linear model with covariates being noise types.
```{r linMods, options}
lmTrivSource = lm(
  spmTriv ~ -1 + byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
  data=d
)
lmNTcoefs = summary(lmTrivSource)$coefficients
signCoefs = lmNTcoefs[lmNTcoefs[,4]<1e-2, ]
lmNTcoefs # all coefficients
signCoefs # significant coefficients
```


<!-- ```{r numericVals, options} -->
<!-- dNumeric = select_if(d,is.numeric) -->
<!-- # head(dNumeric[,2:7]) -->
<!-- lmTrivSource = lm(spmTriv~., data = dNumeric[2:7]) -->
<!-- lmTrivCoefs = summary(lmTrivSource)$coefficients -->
<!-- lmTIntercept = lmTrivCoefs['(Intercept)', 'Estimate'] -->
<!-- lmTBygg = lmTrivCoefs['byggestoy1', 'Estimate'] -->
<!-- lmTPers = lmTrivCoefs['personstoy1', 'Estimate'] -->
<!-- lmTVift = lmTrivCoefs['vifte1', 'Estimate'] -->
<!-- yEst = lmTBygg*(1:5) + lmTPers*(1:5) + lmTVift*(1:5) -->
<!-- plot(dNumeric[,'byggestoy1'], dNumeric[,'spmTriv'], ) -->
<!-- plot(yEst) -->
<!-- ``` -->

# Pairs plots
```{r pairs, options}
# pairs(dNumeric[,2:7])
library(GGally)
dNumeric = select_if(d,is.numeric)
ggpairs(dNumeric[,2:7]) # Trivsel pairs
ggpairs(dNumeric[,8:13]) # Effektivitet pairs
```

# Noise type analysis
In this section we will take a look at each noise type and how much people feel like it influences their efficiency and well-being. First we consider what each individual has set the noise type influence e.g., `byggestoy1`$=3$, and then we consider a weighted result where the wights are the overall influence divided by $5$, e.g., `effektivitet/5*byggestoy1`.

## These uncertainties might be wrong!
```{r noiseTypes, eval=T}
# setup
ntColnames = c('Konstruksjon', 'Person', 'Trafikk', 'Vifte', 'Annet')
nts = c('Konstruksjon', 'Person', 'Trafikk', 'Vifte', 'Annet')
ntTriv = colnames(d)[7:11]
ntEff = colnames(d)[13:17]

# compute mean and sd unweighted
# mean(d[, 'vifte1'])
ntDf = data.frame(cbind(
  nts=1:length(nts),
  meanEff=apply(d[, ntEff], FUN = mean, MARGIN = 2),
  sdEff=apply(d[, ntEff], FUN = sd, MARGIN = 2),
  meanTriv=apply(d[, ntTriv], FUN = mean, MARGIN = 2),
  sdTriv=apply(d[, ntTriv], FUN = sd, MARGIN = 2)
))

# compute mean and sd weighted
ntDfW = data.frame(cbind(
  nts=1:length(nts),
  meanEff=apply(d[, ntEff]*(d$spmEff/5), FUN = mean, MARGIN = 2),
  sdEff=apply(d[, ntEff]*(d$spmEff/5), FUN = sd, MARGIN = 2),
  meanTriv=apply(d[, ntTriv]*(d$spmEff/5), FUN = mean, MARGIN = 2),
  sdTriv=apply(d[, ntTriv]*(d$spmEff/5), FUN = sd, MARGIN = 2)
))

# Plot not weighted
ntDf_maxMean = max(ntDf[,c('meanEff','meanTriv')])
ntDf_maxSD = max(ntDf[,c('sdEff','sdTriv')])

ntDfLong <- ntDf |> 
  pivot_longer(cols = -nts,names_to = "Type") |>
  mutate(scaled_value=ifelse(
    Type %in% c('meanEff','meanTriv'),
    value,
    value/ntDf_maxSD*ntDf_maxMean))
# head(ntDfLong)

# æ is \u00E6
# ø is \u00F8
# å is \u00E5
ggplot(ntDfLong,aes(x=nts, y = scaled_value,fill= Type)) + 
  geom_col(position="dodge") + 
  scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
  scale_fill_manual(
    values = c('#59f7ea', '#be77f9', "#ccfcf9", '#dbbcf5'),
    labels = c('Effektivitet', 'Trivsel', 'SD Effektivitet', 'SD Trivsel')
  ) +
  labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
  scale_x_discrete(limit = nts)+
  theme_minimal() + 
  theme(legend.title = element_blank())

# With conf int bars
# ntDfMean = ntDf[, c('nts','meanEff', 'meanTriv')]
# ntDfSd = ntDf[, c('nts','sdEff', 'sdTriv')]
# ntDfMeanLong <- ntDfMean |> 
#   pivot_longer(cols = -nts,names_to = "Type")
# ntDfSdLong <- ntDfSd |> 
#   pivot_longer(cols = -nts,names_to = "Type")
# ntDfMeanLong$sd = ntDfSdLong$value

# ggplot(ntDfMeanLong, aes(x=nts, y = value,fill= Type)) + 
#   geom_col(position="dodge") + 
#   # scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
#   scale_fill_manual(
#     values = c('#59f7ea', '#be77f9'),
#     labels = c('Effektivitet', 'Trivsel')
#   )+
#   geom_errorbar(
#     aes(
#       # x=nts,
#       ymin = value - 1.96*sd,
#       ymax = value + 1.96*sd),
#       color = "black",
#     position=position_dodge(.9),
#     width=.2
#   ) +
#   # facet_grid(cols = vars(Type))+
#   labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
#   scale_x_discrete(limit = nts)+
#   theme_minimal() + 
#   theme(legend.title = element_blank())



# Plot Weighted
ntDfW_maxMean = max(ntDfW[,c('meanEff','meanTriv')])
ntDfW_maxSD = max(ntDfW[,c('sdEff','sdTriv')])

ntDfWLong <- ntDfW |> 
  pivot_longer(cols = -nts,names_to = "Type") |>
  mutate(scaled_value=ifelse(
    Type %in% c('meanEff','meanTriv'),
    value,
    value/ntDfW_maxSD*ntDfW_maxMean))

ggplot(ntDfWLong, aes(x=nts, y = scaled_value,fill= Type)) + 
  geom_col(position="dodge") + 
  scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
  scale_fill_manual(
    values = c('#59f7ea', '#be77f9', "#ccfcf9", '#dbbcf5'),
    labels = c('Effektivitet', 'Trivsel', 'SD Effektivitet', 'SD Trivsel')
  ) +
  labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
  scale_x_discrete(limit = nts)+
  theme_minimal() + 
  theme(legend.title = element_blank())

```

```{r saveNoiseTypes, eval=F, include=F}
pdf(file = './figures/noiseTypeBar.pdf', width = 6,height = 6)
ggplot(ntDfLong,aes(x=nts, y = scaled_value,fill= Type)) + 
  geom_col(position="dodge") + 
  scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
  scale_fill_manual(
    values = c('#59f7ea', '#be77f9', "#ccfcf9", '#dbbcf5'),
    labels = c('Effektivitet', 'Trivsel', 'SD Effektivitet', 'SD Trivsel')
  )+
  labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
  scale_x_discrete(limit = nts)+
  theme_minimal() + 
  theme(legend.title = element_blank())
dev.off()
```


# Noise types with confidence intervals
TODO: Need to manually verify the confidence intervals!
```{r ntConfInt, options}
# With confInt
CI(d[,'byggestoy1'])

ntDfCi = data.frame(
  cbind(
    nts=1:length(nts),
    t(apply(d[,ntEff], FUN = CI, MARGIN=2)),
    t(apply(d[,ntTriv], FUN = CI, MARGIN=2))
    )
)

# colnames(ntDfCi)
meansTemp = c('nts','mean','mean.1')
upperTemp = c('nts','upper','upper.1')
lowerTemp = c('nts','lower','lower.1')
dfMTemp = ntDfCi[,meansTemp]
dfUTemp = ntDfCi[,upperTemp]
dfLTemp = ntDfCi[,lowerTemp]

ntDfCiLong <- dfMTemp|>
  pivot_longer(cols=-nts, names_to='Type')
ntDfULong = dfUTemp |>
  pivot_longer(cols=-nts, names_to='Type')
ntDfLLong = dfLTemp |>
  pivot_longer(cols=-nts, names_to='Type')

ntDfCiLong$upper=ntDfULong$value
ntDfCiLong$lower=ntDfLLong$value

ntDfCiLong$nts=nts[ntDfCiLong$nts]
# rep(c('eff','triv'), as.integer(length(nts)))
ntDfCiLong$Type=rep(c('eff','triv'), as.integer(length(nts)))
colnames(ntDfCiLong) = c('nts', 'Type', 'mean', 'upper', 'lower')

ggplot(ntDfCiLong, aes(x=nts, y = mean ,fill= Type)) + 
  geom_col(position="dodge") + 
  # scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
  scale_fill_manual(
    values = c('#59f7ea', '#be77f9'),
    labels = c('Effektivitet', 'Trivsel')
  )+
  geom_errorbar(
    aes(
      # x=nts,
      ymin = lower,
      ymax = upper),
      color = "black",
    position=position_dodge(.9),
    width=.4
  ) +
  # facet_grid(cols = vars(Type))+
  labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
  scale_x_discrete(limit = nts)+
  theme_minimal() + 
  theme(legend.title = element_blank())
```

```{r saveNTconfInt, eval=F, include=F}
pdf(file = './figures/noiseTypeBarConfInt.pdf', width = 6,height = 6)
ggplot(ntDfCiLong, aes(x=nts, y = mean ,fill= Type)) + 
  geom_col(position="dodge") + 
  # scale_y_continuous(sec.axis = sec_axis(~ . /ntDf_maxMean*ntDf_maxSD , name = "Standardavvik"))+
  scale_fill_manual(
    values = c('#59f7ea', '#be77f9'),
    labels = c('Effektivitet', 'Trivsel')
  )+
  geom_errorbar(
    aes(
      # x=nts,
      ymin = lower,
      ymax = upper),
      color = "black",
    position=position_dodge(.9),
    width=.4
  ) +
  # facet_grid(cols = vars(Type))+
  labs(y="P\u00E5virkning", x="St\u00F8ytype") + 
  scale_x_discrete(limit = nts)+
  theme_minimal() + 
  theme(legend.title = element_blank())
dev.off()
```




# Kjel and varme skit
Combine `kjel` and `varme` because of struggle with polygons in "building colored" map.
```{r kjelVarme, options}
nKjel = length(d[d$spmHvor=='kjel',1])
nVarme = length(d[d$spmHvor=='varme',1])
nKV = nKjel + nVarme
vkTriv = c(
  d[d$spmHvor=='kjel','spmTriv'],
  d[d$spmHvor=='varme','spmTriv']
)
vkEff = c(
  d[d$spmHvor=='kjel','spmEff'],
  d[d$spmHvor=='varme','spmEff']
)
mTriv = mean(vkTriv)
mEff = mean(vkEff)
sdTriv = sd(vkTriv)
sdEff = sd(vkEff)
c(mTriv,mEff,sdTriv,sdEff)
```




# ANC and noise type correlation
We will look at noise types and how much they disturb when the individual uses ANC compared to when the individual is not.
```{r ANCNoisetype, options}
# ntTriv = colnames(d)[7:11]
# ntEff = colnames(d)[13:17]
ntColnames = c(
  'Konstruksjon', 'Person', 'Trafikk', 'Vifte', 'Annet')
ntRownames = c(
  'Trivsel m/ ANC', 'Trivsel u/ ANC', 'Effektivitet m/ ANC',
  'Effektivitet u/ ANC')
ntAnc = data.frame(
  matrix(
    ncol = length(ntTriv), nrow = 4,
    dimnames=list(ntRownames, ntColnames)
  )
)
ntAncSD = data.frame(
  matrix(
    ncol = length(ntTriv), nrow = 4,
    dimnames=list(ntRownames, ntColnames)
  )
)

# Find mean noise type disturbances
ancBool = d[,"spmTiltak_1"] == "mNc"
ntAnc[ntColnames] = rbind(
  apply(d[ancBool, ntTriv], FUN = mean, MARGIN = 2),
  apply(d[!ancBool, ntTriv], FUN = mean, MARGIN = 2),
  apply(d[ancBool,ntEff], FUN = mean, MARGIN = 2),
  apply(d[!ancBool,ntEff], FUN = mean, MARGIN = 2)
)
ntAncSD[ntColnames] = rbind(
  apply(d[ancBool, ntTriv], FUN = sd, MARGIN = 2),
  apply(d[!ancBool, ntTriv], FUN = sd, MARGIN = 2),
  apply(d[ancBool,ntEff], FUN = sd, MARGIN = 2),
  apply(d[!ancBool,ntEff], FUN = sd, MARGIN = 2)
)

# Barplot
reOrder = c(1,3,2,4)
cols = c("#b1fbf5", '#d5a7fb', '#59f7ea', '#be77f9')

# Mean
barplot(
  ((as.matrix(ntAnc[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  # las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')

# SD
ntAncSDrange = max(ntAncSD)
barplot(
  ((as.matrix(ntAncSD[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  # las=2,
  ylim = c(0,ntAncSDrange*(1+0.3))
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')
```

```{r saveANCnoiseType, eval=F, include=F}
par(mar=defaultMar-c(0,0,1,0))

# Mean
pdf(file = './figures/histANCnoiseType.pdf', width = 6,height = 6)
barplot(
  ((as.matrix(ntAnc[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  # las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')
dev.off()

# SD
pdf(file = './figures/histANCnoiseTypeSD.pdf', width = 6,height = 6)
barplot(
  ((as.matrix(ntAncSD[reOrder,]))), 
  col = cols[reOrder],
  border = "white",
  # main="Trivsel",
  ylab="Standardavvik",
  beside = T,
  # las=2,
  ylim = c(0,ntAncSDrange*(1+0.3))
  # space=0.1
)
legend(
  "top",
  legend = ntRownames[reOrder],
  fill = cols[reOrder], bty = 'n')
dev.off()

par(mar=defaultMar)
```

