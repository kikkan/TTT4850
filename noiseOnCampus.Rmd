---
title: "Title"
author: "Christian Oppegård Moen"
date: "DD MM YYYY"
output: 
  bookdown::pdf_document2:
    toc_depth: '3' # Depth of contents
    number_sections: false
  # pdf_document:
  # #   toc: no
  #   toc_depth: '3'
subtitle: Course
urlcolor: blue
editor_options: 
  chunk_output_type: console
header-includes:
- \usepackage[width=0.8\textwidth]{caption} # add caption to figures.
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = T, tidy=T, message=F, warning=F,
  strip.white=F, # Strips whitespace
  prompt=F, #?
  cache=T, # Cache for quick knit.
  # root.dir = "./subfolder",
  size="scriptsize",
  fig.width=7, 
  fig.height=5, 
  fig.align = "center"
)
```



```{r config, include=F}
if (F){
  setwd("C:/Users/kikka/OneDrive - NTNU/Fysmat/8 Semester V2022/RomStat/romstat/project3")
  options(error=recover)
  options(error=NULL)
}
```

```{r librarys, options}
library(glmm)
library(dplyr)
```

# Data
Dataformat is of tab separated values regarding noise on campus. Some variables are shown in the printout below. The response is `spm3` and `spm4` which are "trivsel" and "effektivitet", respectively. The response is evaluated for each building block.


## Load and reformat
```{r reformatTime, options}
pathData = "./data"
d = read.delim("./data/data-315297-2023-02-22-0953-utf.txt", header=T)

# Time
formatTime <- function(t) {
  tSplit = strsplit(t, ' ')[[1]]
  s=0
  for (i in seq(1, length(tSplit), 2)){
    s = s + switch(
      tSplit[i+1],
      "dager" = strtoi(tSplit[i])*24*3600,
      "dag" = strtoi(tSplit[i])*24*3600,
      "timer" = strtoi(tSplit[i])*3600,
      "time" = strtoi(tSplit[i])*3600,
      "minutt" = strtoi(tSplit[i])*60,
      "minutter" = strtoi(tSplit[i])*60,
      "sekunder" = strtoi(tSplit[i]),
      "sekund" = strtoi(tSplit[i]),
      0
    )
  }
  return(s)
}

ftimes = unlist(lapply(d$Svartid, formatTime))
cbind(d$Svartid, ftimes)
d$Svartid=ftimes

# Free text answers

```

```{r freeTextToFile, options}
write.csv(d[d[,'spmTekst']!="",c('NR','spmTekst')],"./data/freeTxt.csv", row.names = FALSE)

```

## Make response
As mentioned, the responses are `spm3` and `spm4`.
```{r meanPerBuilding, options}
# head(d)
# variates = names(d)
# yt = d$spmTriv
# ye = d$spmEff
locs = unique(d$spmHvor)
locs
```


```{r anc, options}
N = length(d[,1])
ancPercentage = length(d$spmTiltak_1[d$spmTiltak_1=='mNc']) / N
ancPercentage
```

## Response (empirical mean and sd)
```{r response, options}
buildMeans = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
buildSd = data.frame(
  matrix(ncol=length(locs),
         nrow=2, 
         dimnames=list(c('trivsel', 'effektivitet'), locs))
  )
for (loc in locs){
  # browser()
  buildMeans[loc] = c(mean(d$spmTriv[d$spmHvor==loc]),
             mean(d$spmEff[d$spmHvor==loc]))
  buildSd[loc] = c(sd(d$spmTriv[d$spmHvor==loc]),
             sd(d$spmEff[d$spmHvor==loc]))
} 
buildMeans[1:5]
buildSd[1:5]
# Write to file

```

```{r writeTo.dat, options}
# means
write.table(
  t(buildMeans['trivsel',]), 
  file= paste(pathData,'/trivselPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildMeans['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygning.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
# Standard deviations (sd)
write.table(
  t(buildSd['trivsel',]), 
  file= paste(pathData,'/trivselPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
write.table(
  t(buildSd['effektivitet',]), 
  file= paste(pathData,'/effektivitetPerBygningSD.dat',sep = ""), 
  row.names = T, sep = ',', quote = F
)
```

```{r barplotSave, include=FALSE, eval=FALSE}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5
pdf(file = './figures/histTrivsel&Effektivitet.pdf', width = 10,height = 6)
barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
dev.off()
```

```{r barplotResponses, options}
# æ is \u00E6
# ø is \u00F8
# å is \u00E5
barplot(
  ((as.matrix(buildMeans))), 
  col = c("lightblue", 'darkblue'),
  border = "white",
  # main="Trivsel",
  ylab="P\u00E5virkning",
  beside = T,
  las=2,
  ylim = c(0,5)
  # space=0.1
)
legend(
  "top",
  legend = c("Trivsel", "Effektivitet"),
  fill = c("lightblue", 'darkblue'), bty = 'n')
```


# Make building data
```{r buildingSpecificVariables, options}
buildings = split(d, f=d$spmHvor)
for (build in buildings){
  print(mean(build$spmTriv))
}
```

# GLMM fit on errytin'
```{r GLMMall, eval=F}
set.seed(420)
fitAll = glmm(spmTriv~0+Svartid, varcomps.names = c(""), data = d, family.glmm = Gaussian)
dSummary = summary(d)
head(d)
```

# GLM fit on Svartid
```{r GLMtid, options}
# Fit
fitTidTriv = glm(factor(spmTriv, seq(1,5,1))~Svartid , data = d, family = "binomial")
fitTidEff = glm(factor(spmEff, seq(1,5,1))~Svartid , data = d, family = "binomial")

summary(fitTidTriv)$coefficients
summary(fitTidEff)$coefficients
summary(fitTidEff)
```

# GLM fit on noise types
```{r glmNoiseTypes, options}
factors = c('spmTriv', 'spmEff',
            'byggestoy1', 'personstoy1','trafikk1','vifte1', 'annet1',
            'byggestoy2', 'personstoy2','trafikk2','vifte2', 'annet2'
            )
dFactored = d
# factorize = function()
for (f in factors){
  dFactored[f,] = factor(d[f,], seq(1,5,1), ordered = T)
}

fitTrivSource = glm(
  factor(spmTriv, seq(1,5,1), ordered = T)~byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
  data = dFactored, family = "binomial"
)
summary(fitTrivSource)
cov(d$spmTriv, d$byggestoy1)
cov(d$spmEff, d$byggestoy2)
par(d)
```

# Initial data observations
```{r initial, options}
hist(d$spmTriv, breaks = seq(0.5,5.5,1), freq = F)
lines(density(d$spmTriv, bw=1, from = 1, to = 5))
hist(d$spmEff, breaks = seq(0.5,5.5,1), freq = F)
lines(density(d$spmEff, bw=1, from = 1, to = 5))
```


# Linear models
```{r linMods, options}
lmTrivSource = lm(
  spmTriv ~ byggestoy1 + personstoy1 + trafikk1 + vifte1 + annet1,
  data=d
)
summary(lmTrivSource)
# pairs(d[,apply(d[1,],2, FUN=is.numeric)])
```

```{r numericVals, options}
dNumeric = select_if(d,is.numeric)
head(dNumeric[,2:7])
lmTrivSource = lm(spmTriv~., data = dNumeric[2:7])
lmTrivCoefs = summary(lmTrivSource)$coefficients
lmTIntercept = lmTrivCoefs['(Intercept)', 'Estimate']
lmTBygg = lmTrivCoefs['byggestoy1', 'Estimate']
lmTPers = lmTrivCoefs['personstoy1', 'Estimate']
lmTVift = lmTrivCoefs['vifte1', 'Estimate']
yEst = lmTBygg*(1:5) + lmTPers*(1:5) + lmTVift*(1:5)
plot(dNumeric[,'byggestoy1'], dNumeric[,'spmTriv'], )
plot(yEst)
```

```{r pairs, options}
pairs(dNumeric[,2:7])
library(GGally)
ggpairs(dNumeric[,2:7])
ggpairs(dNumeric[,8:13])
```

# Building relations
```{r buildingLm, options}

```

